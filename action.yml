name: "Release GAP package"
description: "Makes a release of the GAP package on GitHub, with archives and manuals as assets"
inputs:
  dry-run:
    description: "Set to true to not push the release to GitHub"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: "Validate PackageInfo.g"
      shell: bash
      run: |
        gap -A -q -c 'QuitGap(ValidatePackageInfo("PackageInfo.g"));'

    - name: "Generate package-info.json"
      shell: bash
      run: |
        gap -A -q $GITHUB_ACTION_PATH/pkginfo_to_json.g
        if [ ! -f "package-info.json" ] ; then
            echo "Could not create package-info.json"
            exit 1
        fi
        echo "ASSETS=package-info.json" >> "$GITHUB_ENV"
        
    - name: "Read data from package-info.json"
      shell: bash
      run: |
        TMP=($(cat package-info.json | jq -r '.ArchiveURL' | tr "/" " "))
        if [ "${#TMP[@]}" -eq 8 ] &&
           [ "${TMP[0]}" = "https:" ] &&
           [ "${TMP[1]}" = "github.com" ] &&
           [ "${TMP[4]}" = "releases" ] &&
           [ "${TMP[5]}" = "download" ]; then
            echo "TAG=${TMP[6]}" >> "$GITHUB_ENV"
            echo "BASENAME=${TMP[7]}" >> "$GITHUB_ENV"
        else
            echo "ArchiveURL in PackageInfo.g does not point to a GitHub release"
            exit 1
        fi
        echo "PKGNAME=$(cat package-info.json | jq -r '.PackageName')" >> "$GITHUB_ENV"
        echo "VERSION=$(cat package-info.json | jq -r '.Version')" >> "$GITHUB_ENV"
        echo "ARCHIVE_FORMATS=$(cat package-info.json | jq -r '.ArchiveFormats' | tr "," " ")" >> "$GITHUB_ENV"
        echo "DOCS=$(cat package-info.json | jq -r '.PackageDoc[].PDFFile' | tr "\n" " ")" >> "$GITHUB_ENV"

    - name: "Make copy in subfolder"
      shell: bash
      run: |
        shopt -s extglob
        mkdir -p "$BASENAME"
        cp -r !($BASENAME|package-info.json) "$BASENAME"
        
    - name: "Cleanup before making archives"
      shell: bash
      working-directory: ${{ env.BASENAME }}
      run: | 
         echo "::group:: Cleanup git and github related files"
         rm -rvf .git* .hg* .cvs* .circleci
         rm -fv .codecov.* .travis.* .appveyor.* azure-pipelines.*
         rm -fv .gaplint.*
         rm -fv requirements.txt
         rm -fv __DOC_CHECKER__.g output.log

         echo "::group:: Cleanup macOS metadata"
         find . -name .DS_Store -exec rm -f {} +

         echo "::group:: Cleanup LaTeX auxiliary files"
         find doc \( -name '*.aux' -o -name '*.bbl' -o -name '*.blg' -o -name '*.brf' -o -name '*.idx' -o -name '*.ilg' -o -name '*.ind' -o -name '*.log' -o -name '*.out' -o -name '*.pnr' -o -name '*.toc' -o -name '*.tst' \) -exec rm -f {} +

    - name: "Create archives"
      shell: bash
      run: |
        for EXT in $ARCHIVE_FORMATS ; do
            ARCHIVENAME=$BASENAME$EXT
            echo "Creating $ARCHIVENAME ..."
            case $EXT in
            .tar.gz)  tar cf - "$BASENAME" | gzip -9c > "$ARCHIVENAME" ;;
            .tar.bz2) tar cf - "$BASENAME" | bzip2 -9c > "$ARCHIVENAME" ;;
            .zip)     zip -r9 --quiet "$ARCHIVENAME" "$BASENAME" ;;
            *)
                echo "Unsupported archive format $EXT"
                exit 1
                ;;
            esac
            if [ ! -f "$ARCHIVENAME" ] ; then
                echo "Failed at creating "$ARCHIVENAME""
                exit 1
            fi
            echo "Created $ARCHIVENAME"
            ASSETS="$ASSETS\n$ARCHIVENAME"
        done
        echo -e "ASSETS<<EOF\n$ASSETS\nEOF" >> "$GITHUB_ENV"

    - name: "Copy manual(s)"
      shell: bash
      run: |
        for DOC in $DOCS ; do
            DOCFILE=$(basename $DOC)
            cp $DOC $DOCFILE
            if [ ! -f "$DOCFILE" ] ; then
                echo "Failed at copying $DOCFILE"
                exit 1
            fi
            ASSETS="$ASSETS\n$DOCFILE"
        done
        echo -e "ASSETS<<EOF\n$ASSETS\nEOF" >> "$GITHUB_ENV"

    - name: "Make GitHub release"
      uses: softprops/action-gh-release@v2
      if: ${{ inputs.dry-run == 'false' }}
      with:
        body: "Release for ${{ env.PKGNAME }}"
        name: "${{ env.PKGNAME }} ${{ env.VERSION }}"
        fail_on_unmatched_files: true
        tag_name: "${{ env.TAG }}"
        files: ${{ env.ASSETS }}

    - name: "Upload the release"
      uses: actions/upload-artifact@v4
      if: ${{ inputs.dry-run == 'true' }}
      with:
        name: "Release_for_${{ env.PKGNAME }}_${{ env.VERSION }}"
        path: ${{ env.ASSETS }}
        if-no-files-found: error
