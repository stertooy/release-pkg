---
name: "Release GAP package"
description: "Makes a release of the GAP package on GitHub, with archives and manuals as assets"
inputs:
  dry-run:
    description: "Set to true to create an archive containing the release instead of publishing it on GitHub"
    required: false
    default: "false"
  force:
    description: "Set to true to allow this action to overwrite an existing release, and to make a release with an incorrect date"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:

    - name: "Validate PackageInfo.g"
      shell: bash
      run: |
        gap -A -q -c 'QuitGap(ValidatePackageInfo("PackageInfo.g"));'

    - name: "Create assets folder"
      shell: bash
      run: |
        ASSETS=$RUNNER_TEMP/assets
        mkdir -p $ASSETS
        echo "ASSETS=$ASSETS" | tee -a "$GITHUB_ENV"

    - name: "Generate package-info.json"
      shell: bash
      run: |
        gap -A -q $GITHUB_ACTION_PATH/pkginfo_to_json.g
        if [ ! -f "package-info.json" ] ; then
            echo "Could not create package-info.json"
            exit 1
        fi
        mv package-info.json $ASSETS

    - name: "Read data from package-info.json"
      shell: bash
      working-directory: ${{ env.ASSETS }}
      run: |
        TMP=($(cat package-info.json | jq -r '.ArchiveURL' | tr "/" " "))
        if [ "${#TMP[@]}" -eq 8 ] &&
           [ "${TMP[0]}" = "https:" ] &&
           [ "${TMP[1]}" = "github.com" ] &&
           [ "${TMP[4]}" = "releases" ] &&
           [ "${TMP[5]}" = "download" ]; then
            echo "TAG=${TMP[6]}" | tee -a "$GITHUB_ENV"
            echo "BASENAME=${TMP[7]}" | tee -a "$GITHUB_ENV"
        else
            echo "ArchiveURL in PackageInfo.g does not point to a GitHub release"
            exit 1
        fi
        echo "PKGNAME=$(cat package-info.json | jq -r '.PackageName')" | tee -a "$GITHUB_ENV"
        echo "VERSION=$(cat package-info.json | jq -r '.Version')" | tee -a "$GITHUB_ENV"
        echo "ARCHIVE_FORMATS=$(cat package-info.json | jq -r '.ArchiveFormats' | tr "," " ")" | tee -a "$GITHUB_ENV"
        echo "DOCS=$(cat package-info.json | jq -r '.PackageDoc[].PDFFile' | tr "\n" " ")" | tee -a "$GITHUB_ENV"
        echo "DATE=$(cat package-info.json | jq -r '.Date')" | tee -a "$GITHUB_ENV"

        case "$VERSION" in
          *dev)
            echo "Must not use 'dev' versions for package releases"
            exit 1
            ;;
        esac

    - name: "Check if tag exists"
      shell: bash
      run: |
        GIT_RELS_JSON=$(wget --header="Authorization: Bearer ${{ github.token }}" -qO- "https://api.github.com/repos/${{ github.repository }}/releases")
        GIT_RELS=$(echo "$GIT_RELS_JSON" | jq -r '.[].tag_name' | sort -V)
        if echo "$GIT_RELS" | grep -q "^${TAG}$"; then
          echo "Tag $TAG is already in use for a release."
          if [[ "${{ inputs.force }}" == "true" ]] ; then
            echo "Forcing update of existing release."
          else
            echo "If you want to overwrite this existing release, re-run this action with the 'force' input set to 'true'."
            exit 1
          fi
        fi

    - name: "Verify the date"
      shell: bash
      if: ${{ inputs.force != 'true' }}
      run: |
        # Convert DD/MM/YYYY to YYYY-MM-DD
        if [[ "$DATE" =~ ^[0-9]{2}/[0-9]{2}/[0-9]{4}$ ]]; then
          DATE=$(echo "$DATE" | awk -F/ '{print $3"-"$2"-"$1}')
        fi
        
        TODAY=$(date +%Y-%m-%d)
        YESTERDAY=$(date -d "yesterday" +%Y-%m-%d)
        TOMORROW=$(date -d "tomorrow" +%Y-%m-%d)

        if [[ "$DATE" != "$TODAY" && "$DATE" != "$YESTERDAY" && "$DATE" != "$TOMORROW" ]]; then
          echo "Date found in PackageInfo.g ($DATE) does not match current date ($TODAY) up to ±1 day."
          exit 1
        fi

    # We make a copy of the current directory to build the release from, because
    # the next step will remove files/folders that may be necessary for subsequent
    # actions
    - name: "Make copy of package"
      shell: bash
      run: |
        mkdir -p "$RUNNER_TEMP/$BASENAME"
        cp -r * "$RUNNER_TEMP/$BASENAME"

    - name: "Cleanup before making archives"
      shell: bash
      working-directory: ${{ runner.temp }}/${{ env.BASENAME }}
      run: |
         echo "::group:: Cleanup git and github related files"
         rm -rvf .git* .hg* .cvs* .circleci
         echo "::group:: Cleanup codecov, travis, azure-pipelines"
         rm -fv .codecov.* .travis.* .appveyor.* azure-pipelines.*
         rm -fv .gaplint.*
         rm -fv requirements.txt

         echo "::group:: Cleanup macOS metadata"
         find . -name .DS_Store -exec rm -f {} +

    - name: "Run autogen.sh"
      shell: bash
      working-directory: ${{ runner.temp }}/${{ env.BASENAME }}
      run : |
        if [ -x autogen.sh ] ; then
          sudo apt-get install autoconf automake build-essential --yes
          echo "Generating build system files"
          sh autogen.sh
          rm -rf autom4te.cache
        fi

    - name: "Check for symlinks"
      shell: bash
      working-directory: ${{ runner.temp }}/${{ env.BASENAME }}
      run : |
        if find . -type l | grep -q .; then
          echo "Symlinks detected"
          exit 1
        fi

    - name: "Reject bad filenames"
      shell: bash
      working-directory: ${{ runner.temp }}/${{ env.BASENAME }}
      run: |
        error_found=false
        
        reserved_names=(
          con  prn  aux  nul
          com1 com2 com3 com4
          com5 com6 com7 com8
          com9 com¹ com² com³
          lpt1 lpt2 lpt3 lpt4
          lpt5 lpt6 lpt7 lpt8
          lpt9 lpt¹ lpt² lpt³
        )
        
        forbidden_chars='[<>:"/\\|?*]'
        
        echo "Checking for Windows-incompatible names"

        mapfile -d '' all_paths < <(find . -printf '%P\0')
        declare -A seen
        
        for p in "${all_paths[@]}"; do
          [[ -z "$p" ]] && continue # skip empty variable caused by root "."

          base="$(basename "$p")"
          base_no_ext="${base%%.*}"
          base_no_ext="${base_no_ext,,}"
          lower="${p,,}"
          
          if [[ "$base" =~ $forbidden_chars ]]; then
            echo "  Illegal character in name: $p"
            error_found=true
          fi
          
          for reserved in "${reserved_names[@]}"; do
            if [[ "$base_no_ext" == "$reserved" ]]; then
              echo "  Reserved Windows name: $p"
              error_found=true
            fi
          done
        
          if [[ "$base" =~ [\ .]$ ]]; then
            echo "  Name ends with space or period: $p"
            error_found=true
          fi
          
          if [[ -n "${seen[$lower]:-}" ]]; then
            echo "  Duplicate filename: ${seen[$lower]} and $p"
            error_found=true
          else
            seen[$lower]="$p"
          fi
        done
        
        if $error_found; then
          exit 1
        fi

    - name: "Create archives"
      shell: bash
      working-directory: ${{ runner.temp }}
      run: |
        for EXT in $ARCHIVE_FORMATS ; do
            ARCHIVENAME=$BASENAME$EXT
            echo "Creating $ARCHIVENAME ..."
            case $EXT in
            .tar.gz)  tar cf - "$BASENAME" | gzip -9c > "$ASSETS/$ARCHIVENAME" ;;
            .tar.bz2) tar cf - "$BASENAME" | bzip2 -9c > "$ASSETS/$ARCHIVENAME" ;;
            .zip)     zip -r9 --quiet "$ASSETS/$ARCHIVENAME" "$BASENAME" ;;
            *)
                echo "Unsupported archive format $EXT"
                exit 1
                ;;
            esac
            if [ ! -f "$ASSETS/$ARCHIVENAME" ] ; then
                echo "Failed at creating "$ARCHIVENAME""
                exit 1
            fi
            echo "Created $ARCHIVENAME"
        done

    - name: "Copy manual(s)"
      shell: bash
      run: |
        for DOC in $DOCS ; do
            cp $DOC $ASSETS
        done

    - name: "Make GitHub release"
      uses: softprops/action-gh-release@v2
      if: ${{ inputs.dry-run == 'false' }}
      with:
        body: "Release for ${{ env.PKGNAME }}"
        name: "${{ env.PKGNAME }} ${{ env.VERSION }}"
        fail_on_unmatched_files: true
        tag_name: "${{ env.TAG }}"
        files: ${{ env.ASSETS }}/*

    - name: "Upload the release"
      uses: actions/upload-artifact@v4
      if: ${{ inputs.dry-run == 'true' }}
      with:
        name: "Release_for_${{ env.PKGNAME }}_${{ env.VERSION }}"
        path: ${{ env.ASSETS }}/*
        if-no-files-found: error
